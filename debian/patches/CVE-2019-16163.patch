Origin: https://github.com/kkos/oniguruma/commit/4097828d7cc87589864fecf452f2cd46c5f37180
Origin: https://github.com/kkos/oniguruma/commit/6b68ebe8360adefe45be94ed0dbf13a9aa9023ef
Last-Update: 2019-09-11
Reviewed-by: Sylvain Beucler <beuc@debian.org>

commit 6b68ebe8360adefe45be94ed0dbf13a9aa9023ef
Author: K.Takata <kentkt@csc.jp>
Date:   Mon Nov 28 23:16:12 2016 +0900

    Set a limit of parser recursion
    
    Our parser uses recursion, so it causes stack overflow when parsing
    deeply nested capture groups. E.g.:
    
      x2("(" * 32767 + "a" + ")" * 32767, "a", 0, 1)
    
    Set a limit for this.
    The default value is defined in regint.h:
    * DEFAULT_PARSE_DEPTH_LIMIT (Currently 4096)

From 4097828d7cc87589864fecf452f2cd46c5f37180 Mon Sep 17 00:00:00 2001
From: "K.Kosako" <kosako@sofnec.co.jp>
Date: Mon, 29 Jul 2019 12:52:56 +0900
Subject: [PATCH] fix #147: Stack Exhaustion Problem caused by some parsing
 functions in regcomp.c making recursive calls to themselves.

Index: libonig-5.9.5/oniguruma.h
===================================================================
--- libonig-5.9.5.orig/oniguruma.h
+++ libonig-5.9.5/oniguruma.h
@@ -533,6 +533,7 @@ ONIG_EXTERN OnigSyntaxType*   OnigDefaul
 #define ONIGERR_UNDEFINED_BYTECODE                            -13
 #define ONIGERR_UNEXPECTED_BYTECODE                           -14
 #define ONIGERR_MATCH_STACK_LIMIT_OVER                        -15
+#define ONIGERR_PARSE_DEPTH_LIMIT_OVER                        -16
 #define ONIGERR_DEFAULT_ENCODING_IS_NOT_SETTED                -21
 #define ONIGERR_SPECIFIED_ENCODING_CANT_CONVERT_TO_WIDE_CHAR  -22
 /* general error */
Index: libonig-5.9.5/regerror.c
===================================================================
--- libonig-5.9.5.orig/regerror.c
+++ libonig-5.9.5/regerror.c
@@ -54,6 +54,8 @@ onig_error_code_to_format(int code)
     p = "fail to memory allocation"; break;
   case ONIGERR_MATCH_STACK_LIMIT_OVER:
     p = "match-stack limit over"; break;
+  case ONIGERR_PARSE_DEPTH_LIMIT_OVER:
+    p = "parse depth limit over"; break;
   case ONIGERR_TYPE_BUG:
     p = "undefined type (bug)"; break;
   case ONIGERR_PARSER_BUG:
Index: libonig-5.9.5/regint.h
===================================================================
--- libonig-5.9.5.orig/regint.h
+++ libonig-5.9.5/regint.h
@@ -74,6 +74,7 @@
 
 #define INIT_MATCH_STACK_SIZE                     160
 #define DEFAULT_MATCH_STACK_LIMIT_SIZE              0 /* unlimited */
+#define DEFAULT_PARSE_DEPTH_LIMIT                4096
 
 #if defined(__GNUC__)
 #  define ARG_UNUSED  __attribute__ ((unused))
Index: libonig-5.9.5/regparse.c
===================================================================
--- libonig-5.9.5.orig/regparse.c
+++ libonig-5.9.5/regparse.c
@@ -97,6 +97,9 @@ extern void onig_set_verb_warn_func(Onig
   onig_verb_warn = f;
 }
 
+
+static unsigned int ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;
+
 static void
 bbuf_free(BBuf* bbuf)
 {
@@ -948,6 +951,7 @@ scan_env_clear(ScanEnv* env)
   env->curr_max_regnum     = 0;
   env->has_recursion       = 0;
 #endif
+  env->parse_depth         = 0;
 }
 
 static int
@@ -4192,6 +4196,9 @@ parse_char_class(Node** np, OnigToken* t
   enum CCVALTYPE val_type, in_type;
   int val_israw, in_israw;
 
+  env->parse_depth++;
+  if (env->parse_depth > ParseDepthLimit)
+    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;
   prev_cc = (CClassNode* )NULL;
   *np = NULL_NODE;
   r = fetch_token_in_cc(tok, src, end, env);
@@ -4495,6 +4502,7 @@ parse_char_class(Node** np, OnigToken* t
     }
   }
   *src = p;
+  env->parse_depth--;
   return 0;
 
  err:
@@ -5043,14 +5051,18 @@ static int
 parse_exp(Node** np, OnigToken* tok, int term,
 	  UChar** src, UChar* end, ScanEnv* env)
 {
-  int r, len, group = 0;
+  int r, len, group;
   Node* qn;
   Node** targetp;
+  unsigned int parse_depth;
 
+  group = 0;
   *np = NULL;
   if (tok->type == (enum TokenSyms )term)
     goto end_of_token;
 
+  parse_depth = env->parse_depth;
+
   switch (tok->type) {
   case TK_ALT:
   case TK_EOT:
@@ -5381,6 +5393,10 @@ parse_exp(Node** np, OnigToken* tok, int
       if (is_invalid_quantifier_target(*targetp))
 	return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;
 
+      parse_depth++;
+      if (parse_depth > ParseDepthLimit)
+        return ONIGERR_PARSE_DEPTH_LIMIT_OVER;
+
       qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,
 			       (r == TK_INTERVAL ? 1 : 0));
       CHECK_NULL_RETURN_MEMERR(qn);
@@ -5475,6 +5491,9 @@ parse_subexp(Node** top, OnigToken* tok,
   Node *node, **headp;
 
   *top = NULL;
+  env->parse_depth++;
+  if (env->parse_depth > ParseDepthLimit)
+    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;
   r = parse_branch(&node, tok, term, src, end, env);
   if (r < 0) {
     onig_node_free(node);
@@ -5508,6 +5527,7 @@ parse_subexp(Node** top, OnigToken* tok,
       return ONIGERR_PARSER_BUG;
   }
 
+  env->parse_depth--;
   return r;
 }
 
Index: libonig-5.9.5/regparse.h
===================================================================
--- libonig-5.9.5.orig/regparse.h
+++ libonig-5.9.5/regparse.h
@@ -306,6 +306,7 @@ typedef struct {
   int curr_max_regnum;
   int has_recursion;
 #endif
+  unsigned int parse_depth;
 } ScanEnv;
 
 
